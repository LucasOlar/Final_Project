<<<<<<< Updated upstream
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
ggplot(data_ch, aes(data_total.date, data_total.confirmed_per_pop_ma)) +
geom_line(size = 1, colour = "blue") +
labs(title = 'COVID-19 Confirmed cases divided per the population in Switzerland',
x = 'Date',
y = 'COVID-19 Confirmed cases divided per the population', ) +
theme_minimal()
```
<br>
<br>
```{r first part first graph b) , echo = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
#Second Graph with Confirmed per pop (i.e. the original variable before smoothing the data) :
ch_plot = ggplot(data_ch, aes(data_total.date, data_total.confirmed_per_pop)) +
geom_line(size = 1, colour = "blue") +
labs(title = 'COVID-19 Confirmed cases divided per the population in Switzerland',
x = 'Date',
y = 'COVID-19 Confirmed cases divided per the population', ) +
theme_minimal()
ch_plot
```
```{r first part second data manipulation, echo = FALSE, message = FALSE, include = FALSE, warning = FALSE}
data_neighbours_1 = ""
data_neighbours_1 = data %>%
filter(data_total.admin == "Germany") %>%
filter(row_number() %% 7 == 1) %>%
select(data_total.admin, data_total.iso_alpha_3, data_total.date, data_total.confirmed_per_pop_ma)
data_neighbours_2 = data %>%
filter(data_total.admin == "Italy") %>%
filter(row_number() %% 7 == 1) %>%
select(data_total.admin,data_total.iso_alpha_3, data_total.date, data_total.confirmed_per_pop_ma)
data_neighbours_3 = data %>%
filter(data_total.admin == "Austria") %>%
filter(row_number() %% 7 == 1) %>%
select(data_total.admin,data_total.iso_alpha_3, data_total.date, data_total.confirmed_per_pop_ma)
data_neighbours_4 = data %>%
filter(data_total.admin == "France") %>%
filter(row_number() %% 7 == 1) %>%
select(data_total.admin,data_total.iso_alpha_3, data_total.date, data_total.confirmed_per_pop_ma)
data_neighbours_5 = data %>%
filter(data_total.admin == "Switzerland") %>%
filter(row_number() %% 7 == 1) %>%
select(data_total.admin,data_total.iso_alpha_3, data_total.date, data_total.confirmed_per_pop_ma)
data_neighbours <- rbind(data_neighbours_1, data_neighbours_2, data_neighbours_3, data_neighbours_4, data_neighbours_5)
data_neighbours = data_neighbours %>% rename(Country = data_total.iso_alpha_3)
```
<br>
<br>
```{r first part second graph, echo = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
eu_plot = ggplot(data_neighbours, aes(x = data_total.date, y = data_total.confirmed_per_pop_ma, color = Country)) +
geom_line(size = 1) +
labs(title = 'COVID-19 Confirmed cases divided per the population',
x = 'Date',
y = 'COVID-19 Confirmed cases divided per the population' , ) +
theme_minimal()
eu_plot
```
```{r first part third data manipulation, echo = FALSE, message = FALSE, include = FALSE, warning = FALSE}
eu_anim = eu_plot + geom_point() + transition_reveal(data_total.date)
```
<br>
<br>
```{r first part third graph, echo = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
eu_anim
```
<br>
<br>
## *PART 2*
<br>
```{r second part first data manipulation, echo = FALSE, include = FALSE, warning = FALSE}
world <- rnaturalearth::ne_countries(scale = "medium", returnclass = "sf")
data_europe = data %>%
filter(data_total.date == as.Date("2022-03-12")) %>%
select(data_total.admin, data_total.confirmed_per_pop_ma)
map <- filter(world, admin %in% data$data_total.admin)
data_map = cbind(data_europe, map)
covid_map = ggplot() +
geom_sf(data = data_map, aes(fill = data_total.confirmed_per_pop_ma, geometry = geometry)) +
coord_sf(xlim = c(-20, 40), ylim = c(35, 70), expand = T) +
labs(title = "covid-19 confirmed cases per population (log): 2022-03-12",
x = 'Latitude',
y = 'Longitude' ) +
theme(legend.position = "bottom") +
theme(legend.text = element_text(size = 4)) +
scale_fill_viridis(trans = "log", name = "confirmed cases divided per population (log)")
```
```{r second part first map, echo = FALSE, warning = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
covid_map
```
```{r second part second data manipulation, echo = FALSE, include = FALSE, warning = FALSE}
date <- seq.Date(as.Date(c("2020-03-01")), Sys.Date(), by = "14 day")
data_europe_dated = data %>%
filter(data_total.date %in% date) %>%
select(data_total.admin, data_total.date, data_total.confirmed_per_pop_ma)
names <- data_europe_dated$data_total.admin
table(names)
# <font color="blue">So there are 54 of each observations </font></p>
map <- map[rep(seq_len(nrow(map)), each = 54), ]
data_maps = cbind(data_europe_dated, map)
plot_covid = ggplot(data = data_maps) +
geom_sf(aes(fill = data_total.confirmed_per_pop_ma, geometry = geometry)) +
coord_sf(xlim = c(-20, 40), ylim = c(35, 70), expand = T) +
labs(x = 'Latitude', y = 'Longitude') +
theme(legend.position = "bottom") +
theme(legend.text = element_text(size = 4)) +
scale_fill_viridis(trans = "log", name = "confirmed cases divided per population (log)") +
transition_states(data_total.date) +
labs(title = 'covid-19 confirmed cases per population (log):' )
```
```{r part 2 animated map, echo = FALSE, warning = FALSE}
animate(plot_covid, fps = 4)
```
<br>
<br>
# ***EXERCISE 2***
```{r exercise 2 data of cars in 1920, echo = FALSE, message = FALSE, include = FALSE, warning = FALSE}
require(stats); require(graphics)
ggplot(cars, xlab = "Speed (mph)", ylab = "Stopping distance (ft)",
las = 1)
lines(lowess(cars$speed, cars$dist, f = 2/3, iter = 3), col = "red")
title(main = "cars data")
ggplot(cars, xlab = "Speed (mph)", ylab = "Stopping distance (ft)",
las = 1, log = "xy")
title(main = "cars data (logarithmic scales)")
lines(lowess(cars$speed, cars$dist, f = 2/3, iter = 3), col = "red")
summary(fm1 <- lm(log(dist) ~ log(speed), data = cars))
opar <- par(mfrow = c(2, 2), oma = c(0, 0, 1.1, 0),
mar = c(4.1, 4.1, 2.1, 1.1))
ggplot(fm1)
par(opar)
library(devtools)
library(tidyverse)
library(knitr)
library(gganimate)
library(ggplot2)
library(dplyr)
library(gapminder)
library(ggthemes)
library(magick)
library(ggplot2)
#TABLE 1
gapminder
LifeExp <- gapminder %>%
select(2,3,4)%>%
group_by(continent,year)%>%
summarise(lifeExp=mean(lifeExp))
#LifeExp graph
graph1 = LifeExp %>%
ggplot(aes(x=year,y=lifeExp, color=continent)) +
geom_line(size=1, alpha = 0.75)
theme_solarized_2(light = FALSE) +
labs(title = "Espérance de vie", y="Age")+
geom_point()
graph1.animation = graph1 +
transition_reveal(year) +
view_follow(fixed_y = TRUE)
gif1 <-animate(graph1.animation, height =300, width = 300, fps = 100, duration = 15, end_pause = 60, res=100)
anim_save("life.gif")
#GDP graph
GDPperCAP <- gapminder%>%
select(2,3,5,6)%>%
group_by(continent,year)%>%
summarise(gdpPercap=mean(gdpPercap),
pop=sum(pop))
graph2<- ggplot(GDPperCAP, aes(x= year, y= gdpPercap, size= pop, color=continent)) +
geom_point(alpha = 0.7, show.legend = FALSE) +
scale_colour_manual(values = continent_colors) +
scale_size(range = c(2, 12)) +
scale_x_log10()+
labs(title = 'Year: {frame_time}', x = 'Year', y = 'GDP PER CAPITA') +
transition_time(year) +
ease_aes('linear')
gif2 <- animate(graph2, height =300, width = 300, fps = 100, duration = 15, end_pause = 60, res=100)
anim_save("GDP.gif")
library(ggplot2)
gif1
gif2
```
# install.packages("devtools")
devtools::install_github("soodoku/tuber", build_vignettes = TRUE)
get_stats(video_id = "N708P-A45D0")
install.packages("dplyr")
install.packages("dplyr")
library(dplyr)
---
title: "Intro_DS_HW2"
author: "Lucas, Matteo, Raphael"
date: '2022-03-24'
output: html_document
---
<center>
# ***EXERCISE 1***
## *PART 1*
```{r data manipulation, echo = FALSE, message = FALSE, include = FALSE, warning = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
library(devtools)
devtools::install_github("SMAC-Group/idar")
library(idar)
=======
filter(grepl(pattern = spoken_languages_input, x = spoken_languages))
genre_1 = "All"             #between : "Action" "Adventure" "Fantasy" "Science Fiction" "Crime" "Drama" "Thriller" "Animation" "Family"
#  "Western" "Comedy" "Romance" "Horror" "Mystery" "History" "War" "Music" "Documentary" "Foreign" "TV Movie"
genre_2 = "Action"
vote_input = 5              #between 0 and 10
popularity_input = 10       #between 0 and 500 (to simplify since only 3 movies above 500)
date_before_input <- as.Date(c("2011-06-15"))
date_after_input <- as.Date(c("2007-06-10"))
runtime_input <- 190        #between 0 and 340
original_language_input <- "es"
#between : "en" "ja" "fr" "zh" "es" "de" "hi" "ru" "ko" "te" "cn" "it" "nl" "ta" "sv" "th" "da" "xx" "hu"
#   "cs" "pt" "is" "tr" "nb" "af" "pl" "he" "ar" "vi" "ky" "id" "ro" "fa" "no" "sl" "ps" "el"
spoken_languages_input <- "English"
#between : "English" "Español" "Français" "Italiano" "Deutsch""Türkçe" "ελληνικά" "普通话" "ภาษาไทย" "Íslenska" "Pусский"
#          "svenska" "Română" "日本語" "Latin" "हिन्दी"   "Português"  "فارسی"          "اردو"             "العربية"  "Český"     "广州话 / 廣州話"  "한국어/조선말"    "Norsk"
#          "தமிழ்"    "" "עִבְרִית"            "Dansk"            "Nederlands"       "Afrikaans"        "Gaeilge"          "Somali"           "suomi"            "Kiswahili"
#          "български език"   "Tiếng Việt"       "Magyar"           "Український"      "Esperanto"        "Polski"           "ਪੰਜਾਬੀ"            "Eesti"            "shqip"            "Srpski"
#          "Bosanski"         "Hrvatski"         "Slovenčina"       "қазақ"            "తెలుగు"            "Cymraeg"          "Wolof"            "isiZulu"          "پښتو"             "No Language"
#          "Galego"           "ქართული"          "বাংলা"            "Català"            "Bahasa indonesia" "Bamanankan"       "Slovenščina"
url <- "https://raw.githubusercontent.com/rengalv/Movies-Data-Analysis-Grab-a-Popcorn/master/tmdb_5000_movies.csv"
#Reading the csv file from the URL
movies <- read_csv(url,col_names = TRUE,na = "NA")
movies <- movies[!duplicated(movies$title), ]
#Takes in the dataframe and column name to be transformed
json_to_df <- function(df, column){
column_1 <- df[apply(df[,column],1,nchar)>2,]  #Checks if there is an entry
list_1 <- lapply(column_1[[column]], fromJSON) #Converts the JSON to a list
values <- data.frame(unlist(lapply(list_1, function(x) paste(x$name,collapse = ",")))) #Collapsing all the values of the list as a key value pair
final_df <- cbind(column_1$id, column_1$title, values) #new data frame with the key and values a s columns
names(final_df)  <- c("id", "title", column)
return(final_df)
}
genres_df <- json_to_df(movies, "genres")
keywords_df <- json_to_df(movies, "keywords")
prod_cntry_df <- json_to_df(movies, "production_countries")
prod_cmpny_df <- json_to_df(movies, "production_companies")
spoken_lang_df <- json_to_df(movies, "spoken_languages")
#Subset the movies dataframe by removing the JSON columns
movies_1 <- subset(movies, select =  -c(genres,keywords,production_companies, production_countries,spoken_languages))
#Join the columns from all the generated dataframes from previous step
movies_df <- movies_1 %>%
full_join(genres_df, by = c("id", "title")) %>%
full_join(keywords_df, by = c("id", "title")) %>%
full_join(prod_cntry_df, by = c("id", "title")) %>%
full_join(prod_cmpny_df, by = c("id", "title")) %>%
full_join(spoken_lang_df, by = c("id", "title"))
#Here we say if user chooses all original languages, then we will pick all the possible languages
if(original_language_input == "All"){
original_language_input <- ""
}
#show all the possible spoken languages
list_spoken_languages <- unlist(strsplit(movies_df$spoken_languages,","))
list_spoken_languages <- list_spoken_languages[!duplicated(list_spoken_languages)]
print(list_spoken_languages)
#Here we say if user chooses all original languages, then we will pick all the possible languages
if(original_language_input == "All"){
original_language_input <- ""
}
#Here we say if user chooses all genres, then we will pick all the possible genres
if(genre_1 == "All" | genre_2 == "All"){
genre_1 <- ""
genre_2 <- ""
}
movies_recommendation = movies_df %>%
filter(status == "Released") %>%
filter(grepl(pattern = genre_1, x = genres)) %>%
filter(grepl(pattern = genre_2, x = genres)) %>%
filter(vote_average >= vote_input) %>%
filter(popularity >= popularity_input) %>%
filter(release_date <= date_before_input) %>%
filter(release_date >= date_after_input) %>%
filter(runtime <= runtime_input) %>%
filter(grepl(pattern = original_language_input, x = original_language)) %>%
filter(grepl(pattern = spoken_languages_input, x = spoken_languages))
genre_1 = "All"             #between : "Action" "Adventure" "Fantasy" "Science Fiction" "Crime" "Drama" "Thriller" "Animation" "Family"
#  "Western" "Comedy" "Romance" "Horror" "Mystery" "History" "War" "Music" "Documentary" "Foreign" "TV Movie"
genre_2 = "Action"
vote_input = 5              #between 0 and 10
popularity_input = 10       #between 0 and 500 (to simplify since only 3 movies above 500)
date_before_input <- as.Date(c("2015-06-15"))
date_after_input <- as.Date(c("1949-06-10"))
runtime_input <- 190        #between 0 and 340
original_language_input <- "es"
#between : "en" "ja" "fr" "zh" "es" "de" "hi" "ru" "ko" "te" "cn" "it" "nl" "ta" "sv" "th" "da" "xx" "hu"
#   "cs" "pt" "is" "tr" "nb" "af" "pl" "he" "ar" "vi" "ky" "id" "ro" "fa" "no" "sl" "ps" "el"
spoken_languages_input <- "English"
#between : "English" "Español" "Français" "Italiano" "Deutsch""Türkçe" "ελληνικά" "普通话" "ภาษาไทย" "Íslenska" "Pусский"
#          "svenska" "Română" "日本語" "Latin" "हिन्दी"   "Português"  "فارسی"          "اردو"             "العربية"  "Český"     "广州话 / 廣州話"  "한국어/조선말"    "Norsk"
#          "தமிழ்"    "" "עִבְרִית"            "Dansk"            "Nederlands"       "Afrikaans"        "Gaeilge"          "Somali"           "suomi"            "Kiswahili"
#          "български език"   "Tiếng Việt"       "Magyar"           "Український"      "Esperanto"        "Polski"           "ਪੰਜਾਬੀ"            "Eesti"            "shqip"            "Srpski"
#          "Bosanski"         "Hrvatski"         "Slovenčina"       "қазақ"            "తెలుగు"            "Cymraeg"          "Wolof"            "isiZulu"          "پښتو"             "No Language"
#          "Galego"           "ქართული"          "বাংলা"            "Català"            "Bahasa indonesia" "Bamanankan"       "Slovenščina"
url <- "https://raw.githubusercontent.com/rengalv/Movies-Data-Analysis-Grab-a-Popcorn/master/tmdb_5000_movies.csv"
#Reading the csv file from the URL
movies <- read_csv(url,col_names = TRUE,na = "NA")
movies <- movies[!duplicated(movies$title), ]
#Takes in the dataframe and column name to be transformed
json_to_df <- function(df, column){
column_1 <- df[apply(df[,column],1,nchar)>2,]  #Checks if there is an entry
list_1 <- lapply(column_1[[column]], fromJSON) #Converts the JSON to a list
values <- data.frame(unlist(lapply(list_1, function(x) paste(x$name,collapse = ",")))) #Collapsing all the values of the list as a key value pair
final_df <- cbind(column_1$id, column_1$title, values) #new data frame with the key and values a s columns
names(final_df)  <- c("id", "title", column)
return(final_df)
}
genres_df <- json_to_df(movies, "genres")
keywords_df <- json_to_df(movies, "keywords")
prod_cntry_df <- json_to_df(movies, "production_countries")
prod_cmpny_df <- json_to_df(movies, "production_companies")
spoken_lang_df <- json_to_df(movies, "spoken_languages")
#Subset the movies dataframe by removing the JSON columns
movies_1 <- subset(movies, select =  -c(genres,keywords,production_companies, production_countries,spoken_languages))
#Join the columns from all the generated dataframes from previous step
movies_df <- movies_1 %>%
full_join(genres_df, by = c("id", "title")) %>%
full_join(keywords_df, by = c("id", "title")) %>%
full_join(prod_cntry_df, by = c("id", "title")) %>%
full_join(prod_cmpny_df, by = c("id", "title")) %>%
full_join(spoken_lang_df, by = c("id", "title"))
#Here we say if user chooses all original languages, then we will pick all the possible languages
if(original_language_input == "All"){
original_language_input <- ""
}
#show all the possible spoken languages
list_spoken_languages <- unlist(strsplit(movies_df$spoken_languages,","))
list_spoken_languages <- list_spoken_languages[!duplicated(list_spoken_languages)]
print(list_spoken_languages)
#Here we say if user chooses all original languages, then we will pick all the possible languages
if(original_language_input == "All"){
original_language_input <- ""
}
#Here we say if user chooses all genres, then we will pick all the possible genres
if(genre_1 == "All" | genre_2 == "All"){
genre_1 <- ""
genre_2 <- ""
}
movies_recommendation = movies_df %>%
filter(status == "Released") %>%
filter(grepl(pattern = genre_1, x = genres)) %>%
filter(grepl(pattern = genre_2, x = genres)) %>%
filter(vote_average >= vote_input) %>%
filter(popularity >= popularity_input) %>%
filter(release_date <= date_before_input) %>%
filter(release_date >= date_after_input) %>%
filter(runtime <= runtime_input) %>%
filter(grepl(pattern = original_language_input, x = original_language)) %>%
filter(grepl(pattern = spoken_languages_input, x = spoken_languages))
shiny::runApp('MovieSorter')
runApp('MovieSorter')
library(shiny)
source(file = "data-finalproject.R", local = T)
ui <- fluidPage(
# Application title
titlePanel("EL PELIROSTER"),
# Sidebar with a slider input for number of bins
sidebarLayout(
sidebarPanel(
selectInput("inputId", "GENRES", "ACTION - ADVENTURE", selected = NULL, multiple = FALSE, selectize = TRUE, width = NULL, size = NULL),
selectInput("inputId", "ACTORS","MEGAN FOX", selected = NULL, multiple = FALSE, selectize = TRUE, width = NULL, size = NULL),
selectInput("inputId", "YEAR","2008", selected = NULL, multiple = FALSE, selectize = TRUE, width = NULL, size = NULL),
),
# Show a plot of the generated distribution
mainPanel(
tabsetPanel(
tabPanel("PELIROSTED", plotOutput("peli")),
tabPanel("RANDOMIZER", plotOutput("rando")),
),
plotOutput("distPlot")
)
)
)
# Define server logic required to draw a histogram
server <- function(input, output) {
output$distPlot <- renderPlot({
# generate bins based on input$bins from ui.R
x    <- faithful[, 2]
bins <- seq(min(x), max(x), length.out = input$bins + 1)
# draw the histogram with the specified number of bins
hist(x, breaks = bins, col = 'darkgray', border = 'white')
})
}
# Run the application
shinyApp(ui = ui, server = server)
?selectInput
?selectInput
runApp('MovieSorter')
getwd()
runApp('MovieSorter')
runApp('MovieSorter')
runApp('MovieSorter')
runApp('MovieSorter')
shiny::runApp('MovieSorter')
runApp('MovieSorter')
runApp('MovieSorter')
list.files()
library(shiny)
source(file = "functions_final_project.R", local = T)
ui <- fluidPage(
# Application title
titlePanel("EL PELIROSTER"),
# Sidebar with a slider input for number of bins
sidebarLayout(
sidebarPanel(
selectInput("inputId", "GENRES 1", c("Action", "Adventure", "Fantasy", "Science Fiction", "Crime", "Drama", "Thriller", "Animation", "Family", "Western",
"Comedy", "Romance", "Horror", "Mystery", "History", "War", "Music", "Documentary", "Foreign", "TV Movie"), selected = NULL, multiple = FALSE, selectize = TRUE, width = NULL, size = 7),
selectInput("inputId", "ACTORS","MEGAN FOX", selected = NULL, multiple = FALSE, selectize = TRUE, width = NULL, size = NULL),
selectInput("inputId", "YEAR","2008", selected = NULL, multiple = FALSE, selectize = TRUE, width = NULL, size = NULL),
),
# Show a plot of the generated distribution
mainPanel(
tabsetPanel(
tabPanel("PELIROSTED", plotOutput("peli")),
tabPanel("RANDOMIZER", plotOutput("rando")),
),
plotOutput("distPlot")
)
)
)
# Define server logic required to draw a histogram
server <- function(input, output) {
output$distPlot <- renderPlot({
# generate bins based on input$bins from ui.R
x    <- faithful[, 2]
bins <- seq(min(x), max(x), length.out = input$bins + 1)
# draw the histogram with the specified number of bins
hist(x, breaks = bins, col = 'darkgray', border = 'white')
})
}
# Run the application
shinyApp(ui = ui, server = server)
runApp()
runApp()
runApp()
runApp()
url <- "https://raw.githubusercontent.com/rengalv/Movies-Data-Analysis-Grab-a-Popcorn/master/tmdb_5000_movies.csv"
#Reading the csv file from the URL
movies <- read_csv(url,col_names = TRUE,na = "NA")
movies <- movies[!duplicated(movies$title), ]
#Takes in the dataframe and column name to be transformed
json_to_df <- function(df, column){
column_1 <- df[apply(df[,column],1,nchar)>2,]  #Checks if there is an entry
list_1 <- lapply(column_1[[column]], fromJSON) #Converts the JSON to a list
values <- data.frame(unlist(lapply(list_1, function(x) paste(x$name,collapse = ",")))) #Collapsing all the values of the list as a key value pair
final_df <- cbind(column_1$id, column_1$title, values) #new data frame with the key and values a s columns
names(final_df)  <- c("id", "title", column)
return(final_df)
}
genres_df <- json_to_df(movies, "genres")
keywords_df <- json_to_df(movies, "keywords")
prod_cntry_df <- json_to_df(movies, "production_countries")
prod_cmpny_df <- json_to_df(movies, "production_companies")
spoken_lang_df <- json_to_df(movies, "spoken_languages")
#Subset the movies dataframe by removing the JSON columns
movies_1 <- subset(movies, select =  -c(genres,keywords,production_companies, production_countries,spoken_languages))
#Join the columns from all the generated dataframes from previous step
movies_df <- movies_1 %>%
full_join(genres_df, by = c("id", "title")) %>%
full_join(keywords_df, by = c("id", "title")) %>%
full_join(prod_cntry_df, by = c("id", "title")) %>%
full_join(prod_cmpny_df, by = c("id", "title")) %>%
full_join(spoken_lang_df, by = c("id", "title"))
View(movies_df)
list_spoken_languages <- unlist(strsplit(movies_df$spoken_languages,","))
list_spoken_languages <- list_spoken_languages[!duplicated(list_spoken_languages)]
print(list_spoken_languages)
runApp()
runApp()
runApp()
runApp()
View(movies_df)
runApp()
runApp()
#Loading the required packages
library(readr)
library(jsonlite)
library(tidyr)
>>>>>>> Stashed changes
library(dplyr)
library(ggplot2)
library(gganimate)
library(viridis)
library(magick)
colnames(data_covid_europe_spatial)
str(data_covid_europe_spatial)
data_total <- data_covid_europe_spatial
data = data.frame(data_total$admin, data_total$iso_alpha_3 ,data_total$date,data_total$confirmed_per_pop_ma, data_total$confirmed_per_pop)
data_ch = data %>%
filter(data_total.admin == "Switzerland") %>%
filter(row_number() %% 7 == 1) %>%
select(data_total.admin, data_total.date, data_total.confirmed_per_pop_ma, data_total.confirmed_per_pop)
```
```{r first part first graph, echo = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
ggplot(data_ch, aes(data_total.date, data_total.confirmed_per_pop_ma)) +
geom_line(size = 1, colour = "blue") +
labs(title = 'COVID-19 Confirmed cases divided per the population in Switzerland',
x = 'Date',
y = 'COVID-19 Confirmed cases divided per the population', ) +
theme_minimal()
```
<br>
<br>
```{r first part first graph b) , echo = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
#Second Graph with Confirmed per pop (i.e. the original variable before smoothing the data) :
ch_plot = ggplot(data_ch, aes(data_total.date, data_total.confirmed_per_pop)) +
geom_line(size = 1, colour = "blue") +
labs(title = 'COVID-19 Confirmed cases divided per the population in Switzerland',
x = 'Date',
y = 'COVID-19 Confirmed cases divided per the population', ) +
theme_minimal()
ch_plot
```
```{r first part second data manipulation, echo = FALSE, message = FALSE, include = FALSE, warning = FALSE}
data_neighbours_1 = ""
data_neighbours_1 = data %>%
filter(data_total.admin == "Germany") %>%
filter(row_number() %% 7 == 1) %>%
select(data_total.admin, data_total.iso_alpha_3, data_total.date, data_total.confirmed_per_pop_ma)
data_neighbours_2 = data %>%
filter(data_total.admin == "Italy") %>%
filter(row_number() %% 7 == 1) %>%
select(data_total.admin,data_total.iso_alpha_3, data_total.date, data_total.confirmed_per_pop_ma)
data_neighbours_3 = data %>%
filter(data_total.admin == "Austria") %>%
filter(row_number() %% 7 == 1) %>%
select(data_total.admin,data_total.iso_alpha_3, data_total.date, data_total.confirmed_per_pop_ma)
data_neighbours_4 = data %>%
filter(data_total.admin == "France") %>%
filter(row_number() %% 7 == 1) %>%
select(data_total.admin,data_total.iso_alpha_3, data_total.date, data_total.confirmed_per_pop_ma)
data_neighbours_5 = data %>%
filter(data_total.admin == "Switzerland") %>%
filter(row_number() %% 7 == 1) %>%
select(data_total.admin,data_total.iso_alpha_3, data_total.date, data_total.confirmed_per_pop_ma)
data_neighbours <- rbind(data_neighbours_1, data_neighbours_2, data_neighbours_3, data_neighbours_4, data_neighbours_5)
data_neighbours = data_neighbours %>% rename(Country = data_total.iso_alpha_3)
```
<br>
<br>
```{r first part second graph, echo = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
eu_plot = ggplot(data_neighbours, aes(x = data_total.date, y = data_total.confirmed_per_pop_ma, color = Country)) +
geom_line(size = 1) +
labs(title = 'COVID-19 Confirmed cases divided per the population',
x = 'Date',
y = 'COVID-19 Confirmed cases divided per the population' , ) +
theme_minimal()
eu_plot
```
```{r first part third data manipulation, echo = FALSE, message = FALSE, include = FALSE, warning = FALSE}
eu_anim = eu_plot + geom_point() + transition_reveal(data_total.date)
```
<br>
<br>
```{r first part third graph, echo = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
eu_anim
```
<br>
<br>
## *PART 2*
<br>
```{r second part first data manipulation, echo = FALSE, include = FALSE, warning = FALSE}
world <- rnaturalearth::ne_countries(scale = "medium", returnclass = "sf")
data_europe = data %>%
filter(data_total.date == as.Date("2022-03-12")) %>%
select(data_total.admin, data_total.confirmed_per_pop_ma)
map <- filter(world, admin %in% data$data_total.admin)
data_map = cbind(data_europe, map)
covid_map = ggplot() +
geom_sf(data = data_map, aes(fill = data_total.confirmed_per_pop_ma, geometry = geometry)) +
coord_sf(xlim = c(-20, 40), ylim = c(35, 70), expand = T) +
labs(title = "covid-19 confirmed cases per population (log): 2022-03-12",
x = 'Latitude',
y = 'Longitude' ) +
theme(legend.position = "bottom") +
theme(legend.text = element_text(size = 4)) +
scale_fill_viridis(trans = "log", name = "confirmed cases divided per population (log)")
```
```{r second part first map, echo = FALSE, warning = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
covid_map
```
```{r second part second data manipulation, echo = FALSE, include = FALSE, warning = FALSE}
date <- seq.Date(as.Date(c("2020-03-01")), Sys.Date(), by = "14 day")
data_europe_dated = data %>%
filter(data_total.date %in% date) %>%
select(data_total.admin, data_total.date, data_total.confirmed_per_pop_ma)
names <- data_europe_dated$data_total.admin
table(names)
# <font color="blue">So there are 54 of each observations </font></p>
map <- map[rep(seq_len(nrow(map)), each = 54), ]
data_maps = cbind(data_europe_dated, map)
plot_covid = ggplot(data = data_maps) +
geom_sf(aes(fill = data_total.confirmed_per_pop_ma, geometry = geometry)) +
coord_sf(xlim = c(-20, 40), ylim = c(35, 70), expand = T) +
labs(x = 'Latitude', y = 'Longitude') +
theme(legend.position = "bottom") +
theme(legend.text = element_text(size = 4)) +
scale_fill_viridis(trans = "log", name = "confirmed cases divided per population (log)") +
transition_states(data_total.date) +
labs(title = 'covid-19 confirmed cases per population (log):' )
```
```{r part 2 animated map, echo = FALSE, warning = FALSE}
animate(plot_covid, fps = 4)
```
<br>
<br>
# ***EXERCISE 2***
```{r exercise 2 data of cars in 1920, echo = FALSE, message = FALSE, include = FALSE, warning = FALSE}
require(stats); require(graphics)
ggplot(cars, xlab = "Speed (mph)", ylab = "Stopping distance (ft)",
las = 1)
lines(lowess(cars$speed, cars$dist, f = 2/3, iter = 3), col = "red")
title(main = "cars data")
ggplot(cars, xlab = "Speed (mph)", ylab = "Stopping distance (ft)",
las = 1, log = "xy")
title(main = "cars data (logarithmic scales)")
lines(lowess(cars$speed, cars$dist, f = 2/3, iter = 3), col = "red")
summary(fm1 <- lm(log(dist) ~ log(speed), data = cars))
opar <- par(mfrow = c(2, 2), oma = c(0, 0, 1.1, 0),
mar = c(4.1, 4.1, 2.1, 1.1))
ggplot(fm1)
par(opar)
library(devtools)
library(tidyverse)
library(knitr)
library(gganimate)
library(ggplot2)
library(dplyr)
library(gapminder)
library(ggthemes)
library(magick)
library(ggplot2)
#TABLE 1
gapminder
LifeExp <- gapminder %>%
select(2,3,4)%>%
group_by(continent,year)%>%
summarise(lifeExp=mean(lifeExp))
#LifeExp graph
graph1 = LifeExp %>%
ggplot(aes(x=year,y=lifeExp, color=continent)) +
geom_line(size=1, alpha = 0.75)
#theme_solarized_2(light = FALSE) +
labs(title = "Espérance de vie", y="Age")+
geom_point()
graph1.animation = graph1 +
transition_reveal(year) +
view_follow(fixed_y = TRUE)
gif1 <-animate(graph1.animation, height =300, width = 300, fps = 100, duration = 15, end_pause = 60, res=100)
anim_save("life.gif")
#GDP graph
GDPperCAP <- gapminder%>%
select(2,3,5,6)%>%
group_by(continent,year)%>%
summarise(gdpPercap=mean(gdpPercap),
pop=sum(pop))
graph2<- ggplot(GDPperCAP, aes(x= year, y= gdpPercap, size= pop, color=continent)) +
geom_point(alpha = 0.7, show.legend = FALSE) +
scale_colour_manual(values = continent_colors) +
scale_size(range = c(2, 12)) +
scale_x_log10()+
labs(title = 'Year: {frame_time}', x = 'Year', y = 'GDP PER CAPITA') +
transition_time(year) +
ease_aes('linear')
gif2 <- animate(graph2, height =300, width = 300, fps = 100, duration = 15, end_pause = 60, res=100)
anim_save("GDP.gif")
library(ggplot2)
gif1
gif2
```
## References
1. McNeil, D. R. (1977) Interactive Data Analysis. Wiley.  (for the car experiment)
2. https://github.com/jennybc/gapminder
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
library(devtools)
devtools::install_github("SMAC-Group/idar")
library(idar)
library(dplyr)
library(ggplot2)
<<<<<<< Updated upstream
library(gganimate)
library(viridis)
library(magick)
colnames(data_covid_europe_spatial)
str(data_covid_europe_spatial)
data_total <- data_covid_europe_spatial
data = data.frame(data_total$admin, data_total$iso_alpha_3 ,data_total$date,data_total$confirmed_per_pop_ma, data_total$confirmed_per_pop)
data_ch = data %>%
filter(data_total.admin == "Switzerland") %>%
filter(row_number() %% 7 == 1) %>%
select(data_total.admin, data_total.date, data_total.confirmed_per_pop_ma, data_total.confirmed_per_pop)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
ggplot(data_ch, aes(data_total.date, data_total.confirmed_per_pop_ma)) +
geom_line(size = 1, colour = "blue") +
labs(title = 'COVID-19 Confirmed cases divided per the population in Switzerland',
x = 'Date',
y = 'COVID-19 Confirmed cases divided per the population', ) +
theme_minimal()
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
#Second Graph with Confirmed per pop (i.e. the original variable before smoothing the data) :
ch_plot = ggplot(data_ch, aes(data_total.date, data_total.confirmed_per_pop)) +
geom_line(size = 1, colour = "blue") +
labs(title = 'COVID-19 Confirmed cases divided per the population in Switzerland',
x = 'Date',
y = 'COVID-19 Confirmed cases divided per the population', ) +
theme_minimal()
ch_plot
data_neighbours_1 = ""
data_neighbours_1 = data %>%
filter(data_total.admin == "Germany") %>%
filter(row_number() %% 7 == 1) %>%
select(data_total.admin, data_total.iso_alpha_3, data_total.date, data_total.confirmed_per_pop_ma)
data_neighbours_2 = data %>%
filter(data_total.admin == "Italy") %>%
filter(row_number() %% 7 == 1) %>%
select(data_total.admin,data_total.iso_alpha_3, data_total.date, data_total.confirmed_per_pop_ma)
data_neighbours_3 = data %>%
filter(data_total.admin == "Austria") %>%
filter(row_number() %% 7 == 1) %>%
select(data_total.admin,data_total.iso_alpha_3, data_total.date, data_total.confirmed_per_pop_ma)
data_neighbours_4 = data %>%
filter(data_total.admin == "France") %>%
filter(row_number() %% 7 == 1) %>%
select(data_total.admin,data_total.iso_alpha_3, data_total.date, data_total.confirmed_per_pop_ma)
data_neighbours_5 = data %>%
filter(data_total.admin == "Switzerland") %>%
filter(row_number() %% 7 == 1) %>%
select(data_total.admin,data_total.iso_alpha_3, data_total.date, data_total.confirmed_per_pop_ma)
data_neighbours <- rbind(data_neighbours_1, data_neighbours_2, data_neighbours_3, data_neighbours_4, data_neighbours_5)
data_neighbours = data_neighbours %>% rename(Country = data_total.iso_alpha_3)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
eu_plot = ggplot(data_neighbours, aes(x = data_total.date, y = data_total.confirmed_per_pop_ma, color = Country)) +
geom_line(size = 1) +
labs(title = 'COVID-19 Confirmed cases divided per the population',
x = 'Date',
y = 'COVID-19 Confirmed cases divided per the population' , ) +
theme_minimal()
eu_plot
eu_anim = eu_plot + geom_point() + transition_reveal(data_total.date)
num1=int(input("Enter num1:"))
num2=int(input("Enter num2:"))
action = str(input("Choose action : Add(a), Sub(s), Mult(m), Div(d) ->"))
print("The result is ",end="")
if action == "a":
print(num1+num2)
elif action == "s":
print(num1-num2)
elif action == "m":
print(num1*num2)
else:
print(num1/num2)
num1=int(input("Enter num1:"))
num2=int(input("Enter num2:"))
action = str(input("Choose action : Add(a), Sub(s), Mult(m), Div(d) ->"))
print("The result is ",end="")
if action == "a":
print(num1+num2)
if action == "s":
print(num1-num2)
if action == "m":
print(num1*num2)
else:
print(num1/num2)
library(shiny); runApp('Documents/GitHub/finalprojectttt/Final_Project/MovieApp.R')
runApp('Documents/GitHub/finalprojectttt/Final_Project/MovieApp.R')
runApp('Documents/GitHub/finalprojectttt/Final_Project/MovieApp.R')
runApp('Documents/GitHub/finalprojectttt/Final_Project/MovieApp.R')
runApp('Documents/GitHub/finalprojectttt/Final_Project/MovieApp.R')
runApp('Documents/GitHub/finalprojectttt/Final_Project/MovieApp.R')
library(shiny); runApp('Documents/GitHub/finalprojectttt/Final_Project/MovieApp.R')
runApp('Documents/GitHub/finalprojectttt/Final_Project/MovieApp.R')
runApp('Documents/GitHub/finalprojectttt/Final_Project/MovieApp.R')
runApp('Documents/GitHub/finalprojectttt/Final_Project/MovieApp.R')
runApp('Documents/GitHub/finalprojectttt/Final_Project/MovieApp.R')
runApp('Documents/GitHub/finalprojectttt/Final_Project/MovieApp.R')
runApp('Documents/GitHub/finalprojectttt/Final_Project/MovieApp.R')
runApp('Documents/GitHub/finalprojectttt/Final_Project/MovieApp.R')
runApp('Documents/GitHub/finalprojectttt/Final_Project/MovieApp.R')
?sort
library(shiny); runApp('MovieApp.R')
runApp('MovieApp.R')
runApp('MovieApp.R')
runApp('MovieApp.R')
runApp('MovieApp.R')
runApp('MovieApp.R')
runApp('MovieApp.R')
=======
library(ggpubr)
library(tibble)
rm(list = ls())
#We want to create a function that filters based on : 2 genres, vote_average, popularity, 2 release_date, runtime, original language, spoken languages
# colnames(movies_df)
#Show all the possible original languages
# list_languages <- movies_df[!duplicated(movies_df$original_language), ]
# list_languages = list_languages %>%
#   select(original_language)
# unique(list_languages$original_language)
#Show all the possible genres of movies
# list_genres <- unlist(strsplit(movies_df$genres,","))
# list_genres <- list_genres[!duplicated(list_genres)]
# print(list_genres)
#Show all the possible spoken languages
# list_spoken_languages <- unlist(strsplit(movies_df$spoken_languages,","))
# list_spoken_languages <- list_spoken_languages[!duplicated(list_spoken_languages)]
# print(list_spoken_languages)
data_filter = function(genre_1, genre_2, vote_average_input, popularity_input, date_before,
date_after, runtime_input, original_language_input, spoken_languages_input){
url <- "https://raw.githubusercontent.com/rengalv/Movies-Data-Analysis-Grab-a-Popcorn/master/tmdb_5000_movies.csv"
#Reading the csv file from the URL
movies <- read_csv(url,col_names = TRUE,na = "NA")
movies <- movies[!duplicated(movies$title), ]
#Takes in the dataframe and column name to be transformed
json_to_df <- function(df, column){
column_1 <- df[apply(df[,column],1,nchar)>2,]  #Checks if there is an entry
list_1 <- lapply(column_1[[column]], fromJSON) #Converts the JSON to a list
values <- data.frame(unlist(lapply(list_1, function(x) paste(x$name,collapse = ",")))) #Collapsing all the values of the list as a key value pair
final_df <- cbind(column_1$id, column_1$title, values) #new data frame with the key and values a s columns
names(final_df)  <- c("id", "title", column)
return(final_df)
}
genres_df <- json_to_df(movies, "genres")
keywords_df <- json_to_df(movies, "keywords")
prod_cntry_df <- json_to_df(movies, "production_countries")
prod_cmpny_df <- json_to_df(movies, "production_companies")
spoken_lang_df <- json_to_df(movies, "spoken_languages")
#Subset the movies dataframe by removing the JSON columns
movies_1 <- subset(movies, select =  -c(genres,keywords,production_companies, production_countries,spoken_languages))
#Join the columns from all the generated dataframes from previous step
movies_df <- movies_1 %>%
full_join(genres_df, by = c("id", "title")) %>%
full_join(keywords_df, by = c("id", "title")) %>%
full_join(prod_cntry_df, by = c("id", "title")) %>%
full_join(prod_cmpny_df, by = c("id", "title")) %>%
full_join(spoken_lang_df, by = c("id", "title"))
#Here we say if user chooses all original languages, then we will pick all the possible languages
if(original_language_input == "All"){
original_language_input <- ""
}
#Here we say if user chooses all original languages, then we will pick all the possible languages
if(spoken_languages_input == "All"){
spoken_languages_input <- ""
}
#Here we say if user chooses all genres, then we will pick all the possible genres
if(genre_1 == "All" | genre_2 == "All"){
genre_1 <- ""
genre_2 <- ""
}
movies_recommendation = movies_df %>%
filter(status == "Released") %>%
filter(grepl(pattern = genre_1, x = genres)) %>%
filter(grepl(pattern = genre_2, x = genres)) %>%
filter(vote_average >= vote_average_input) %>%
filter(popularity >= popularity_input) %>%
filter(release_date <= date_before) %>%
filter(release_date >= date_after) %>%
filter(runtime <= runtime_input) %>%
filter(grepl(pattern = original_language_input, x = original_language)) %>%
filter(grepl(pattern = spoken_languages_input, x = spoken_languages))
return(movies_recommendation)
}
data_filter(
genre_1 = "Action",
genre_2 = "Comedy",
vote_average_input = 3,
popularity_input = 39,
date_before = as.Date(c("2017-06-22")),
date_after = as.Date(c("2007-06-22")),
runtime_input = 200,
original_language_input = "en",
spoken_languages_input = "Español")
data_recommend_new <- data_filter(
genre_1 = "Action",
genre_2 = "Comedy",
vote_average_input = 3,
popularity_input = 39,
date_before = as.Date(c("2017-06-22")),
date_after = as.Date(c("2007-06-22")),
runtime_input = 200,
original_language_input = "en",
spoken_languages_input = "Español")
View(data_recommend_new)
runApp()
shiny::runApp()
if(interactive()){
ui <- fluidPage(
# Application title
titlePanel("EL PELIROSTER"),
# Sidebar with a slider input for number of bins
sidebarLayout(
sidebarPanel(
selectInput("genre_1", "GENRES 1", c("All", "Action", "Adventure", "Fantasy", "Science Fiction", "Crime", "Drama", "Thriller",
"Animation", "Family", "Western", "Comedy", "Romance", "Horror", "Mystery", "History", "War",
"Music", "Documentary", "Foreign", "TV Movie"), selected = NULL, multiple = FALSE, width = NULL),
selectInput("genre_2", "GENRES 2", c("All", "Action", "Adventure", "Fantasy", "Science Fiction", "Crime", "Drama", "Thriller",
"Animation", "Family", "Western", "Comedy", "Romance", "Horror", "Mystery", "History", "War",
"Music", "Documentary", "Foreign", "TV Movie"), selected = NULL, multiple = FALSE, width = NULL),
sliderInput("vote_average", "AVERAGE RATING", min = 0, max = 10, value = 5),
sliderInput("popularity", "POPULARITY", min = 0, max = 150, value = 75),
sliderInput("runtime", "MAXIMUM LENGTH (MINUTES)", min = 0, max = 340, value = 170),
dateInput("date_before", "FILMS BEFORE", value = "2017-02-03", format = "dd-mm-yyyy"),
dateInput("date_after", "FILMS AFTER", value = "1916-09-04", format = "dd-mm-yyyy"),
selectInput("original_language", "ORIGINAL LANGUAGE",
c("All", "English" = "en", "Japanese" = "ja", "French" = "fr", "Chinese" = "zh", "Spanish" = "es", "German" = "de",
"Hindi" = "hi", "Russian" = "ru", "Korean" = "ko", "Telugu" = "te", "Catalan" = "cn", "Italian" = "it", "Dutch" = "nl",
"Tamil" = "ta", "Swedish" = "sv", "Thai" = "th", "Danish" = "da", "Hungarian" = "hu", "Czech" = "cs", "Portuguese" = "pt",
"Icelandic" = "is", "Turkish" = "tr", "Norwegian BokmÃ¥l" = "nb", "Afrikaans" = "af", "Polish" = "pl", "Hebrew" = "he",
"Arabic" = "ar", "Vietnamese" = "vi", "Kyrgyz" = "ky", "Indonesian" = "id", "Romanian" = "ro", "Persian" = "fa",
"Norwegian" = "no", "Slovenian" = "sl", "Pashto"= "ps", "Greek" = "el"
), selected = NULL, multiple = FALSE, width = NULL),
selectInput("spoken_languages", "DUBBED LANGUAGE",
c("All", "English", "EspaÃ±ol", "FranÃ§ais", "Italiano", "Deutsch", "TÃ¼rkÃ§e", "ÎµÎ»Î»Î·Î½Î¹ÎºÎ¬",
"æ®éè¯", "à¸ à¸²à¸©à¸²à¹à¸à¸¢", "Ãslenska",  "PÑÑÑÐºÐ¸Ð¹", "svenska", "RomÃ¢nÄ", "æ¥æ¬èª", "Latin",
"à¤¹à¤¿à¤¨à¥à¤¦à¥", "PortuguÃªs", "ÙØ§Ø±Ø³Û" , "Ø§Ø±Ø¯Ù"  ,"Ø§ÙØ¹Ø±Ø¨ÙØ©" , "ÄeskÃ½", "å¹¿å·è¯ / å»£å·è©±",
"íêµ­ì´/ì¡°ì ë§" ,"Norsk", "à®¤à®®à®¿à®´à¯", "×¢Ö´×Ö°×¨Ö´××ª", "Dansk", "Nederlands", "Afrikaans", "Gaeilge",
"Somali", "suomi", "Kiswahili", "Ð±ÑÐ»Ð³Ð°ÑÑÐºÐ¸ ÐµÐ·Ð¸Ðº", "Tiáº¿ng Viá»t", "Magyar", "Ð£ÐºÑÐ°ÑÐ½ÑÑÐºÐ¸Ð¹",
"Esperanto" , "Polski", "à¨ªà©°à¨à¨¾à¨¬à©", "Eesti","shqip","Srpski","Bosanski","Hrvatski","SlovenÄina","ÒÐ°Ð·Ð°Ò",
"à°¤à±à°²à±à°à±", "Cymraeg","Wolof","isiZulu", "Ù¾ÚØªÙ", "No Language",  "Galego","á¥áá áá£áá"  ,
"à¦¬à¦¾à¦à¦²à¦¾" , "CatalÃ ", "Bahasa indonesia" , "Bamanankan" ,"SlovenÅ¡Äina"
), selected = NULL, multiple = FALSE, width = NULL),
actionButton("compute", "Confirm Criteria", icon = icon("film"), class = "btn-success")
),
# Show a plot of the generated distribution
mainPanel(
tabsetPanel(
tabPanel("RECOMMENDATIONS", tableOutput("peli")),
tabPanel("RANDOMIZER"),
tabPanel("PELIRANDOM")
),
)
)
)
# Define server logic required to draw a histogram
server <- function(input, output, session) {
#Use data_filter function from functions_final_project.R to filter with criteria
data_recommend <- eventReactive(input$compute,{
data_filter(
genre_1 = input$genre_1,
genre_2 = input$genre_2,
vote_average_input = input$vote_average,
popularity_input = input$popularity,
date_before = input$date_before,
date_after = input$date_after,
runtime_input = input$runtime,
original_language_input = input$original_language,
spoken_languages_input = input$spoken_languages)
})
#Prints out table (temporary)
output$peli <- renderTable({
choose_movie(data_recommend())
})
observeEvent(input$compute, {
#Remove old buttons
removeUI(selector = "div:has(>> #genre_1)")
removeUI(selector = "div:has(>> #genre_2)")
removeUI(selector = "div:has(> #vote_average)")
removeUI(selector = "div:has(> #popularity)")
removeUI(selector = "div:has(>> #date_before)")
removeUI(selector = "div:has(>> #date_after)")
removeUI(selector = "div:has(> #runtime)")
removeUI(selector = "div:has(>> #original_language)")
removeUI(selector = "div:has(>> #spoken_languages)")
#Change Compute button into accept button
updateActionButton(session, "compute", label = "ANOTHER ONE", icon = icon("recycle"))
})
}
# Run the application
shinyApp(ui = ui, server = server)
}
removeUI(selector = "div:has(>> #spoken_languages)")
removeUI(selector = "div:has(>> #spoken_languages)")
source(file = "functions_final_project.R", local = T)
ui <- fluidPage(
# Application title
titlePanel("EL PELIROSTER"),
# Sidebar with a slider input for number of bins
sidebarLayout(
sidebarPanel(
selectInput("genre_1", "GENRES 1", c("All", "Action", "Adventure", "Fantasy", "Science Fiction", "Crime", "Drama", "Thriller",
"Animation", "Family", "Western", "Comedy", "Romance", "Horror", "Mystery", "History", "War",
"Music", "Documentary", "Foreign", "TV Movie"), selected = NULL, multiple = FALSE, width = NULL),
selectInput("genre_2", "GENRES 2", c("All", "Action", "Adventure", "Fantasy", "Science Fiction", "Crime", "Drama", "Thriller",
"Animation", "Family", "Western", "Comedy", "Romance", "Horror", "Mystery", "History", "War",
"Music", "Documentary", "Foreign", "TV Movie"), selected = NULL, multiple = FALSE, width = NULL),
sliderInput("vote_average", "AVERAGE RATING", min = 0, max = 10, value = 5),
sliderInput("popularity", "POPULARITY", min = 0, max = 150, value = 75),
sliderInput("runtime", "MAXIMUM LENGTH (MINUTES)", min = 0, max = 340, value = 170),
dateInput("date_before", "FILMS BEFORE", value = "2017-02-03", format = "dd-mm-yyyy"),
dateInput("date_after", "FILMS AFTER", value = "1916-09-04", format = "dd-mm-yyyy"),
selectInput("original_language", "ORIGINAL LANGUAGE",
c("All", "English" = "en", "Japanese" = "ja", "French" = "fr", "Chinese" = "zh", "Spanish" = "es", "German" = "de",
"Hindi" = "hi", "Russian" = "ru", "Korean" = "ko", "Telugu" = "te", "Catalan" = "cn", "Italian" = "it", "Dutch" = "nl",
"Tamil" = "ta", "Swedish" = "sv", "Thai" = "th", "Danish" = "da", "Hungarian" = "hu", "Czech" = "cs", "Portuguese" = "pt",
"Icelandic" = "is", "Turkish" = "tr", "Norwegian BokmÃ¥l" = "nb", "Afrikaans" = "af", "Polish" = "pl", "Hebrew" = "he",
"Arabic" = "ar", "Vietnamese" = "vi", "Kyrgyz" = "ky", "Indonesian" = "id", "Romanian" = "ro", "Persian" = "fa",
"Norwegian" = "no", "Slovenian" = "sl", "Pashto"= "ps", "Greek" = "el"
), selected = NULL, multiple = FALSE, width = NULL),
selectInput("spoken_languages", "DUBBED LANGUAGE",
c("All", "English", "EspaÃ±ol", "FranÃ§ais", "Italiano", "Deutsch", "TÃ¼rkÃ§e", "ÎµÎ»Î»Î·Î½Î¹ÎºÎ¬",
"æ®éè¯", "à¸ à¸²à¸©à¸²à¹à¸à¸¢", "Ãslenska",  "PÑÑÑÐºÐ¸Ð¹", "svenska", "RomÃ¢nÄ", "æ¥æ¬èª", "Latin",
"à¤¹à¤¿à¤¨à¥à¤¦à¥", "PortuguÃªs", "ÙØ§Ø±Ø³Û" , "Ø§Ø±Ø¯Ù"  ,"Ø§ÙØ¹Ø±Ø¨ÙØ©" , "ÄeskÃ½", "å¹¿å·è¯ / å»£å·è©±",
"íêµ­ì´/ì¡°ì ë§" ,"Norsk", "à®¤à®®à®¿à®´à¯", "×¢Ö´×Ö°×¨Ö´××ª", "Dansk", "Nederlands", "Afrikaans", "Gaeilge",
"Somali", "suomi", "Kiswahili", "Ð±ÑÐ»Ð³Ð°ÑÑÐºÐ¸ ÐµÐ·Ð¸Ðº", "Tiáº¿ng Viá»t", "Magyar", "Ð£ÐºÑÐ°ÑÐ½ÑÑÐºÐ¸Ð¹",
"Esperanto" , "Polski", "à¨ªà©°à¨à¨¾à¨¬à©", "Eesti","shqip","Srpski","Bosanski","Hrvatski","SlovenÄina","ÒÐ°Ð·Ð°Ò",
"à°¤à±à°²à±à°à±", "Cymraeg","Wolof","isiZulu", "Ù¾ÚØªÙ", "No Language",  "Galego","á¥áá áá£áá"  ,
"à¦¬à¦¾à¦à¦²à¦¾" , "CatalÃ ", "Bahasa indonesia" , "Bamanankan" ,"SlovenÅ¡Äina"
), selected = NULL, multiple = FALSE, width = NULL),
actionButton("compute", "Confirm Criteria", icon = icon("film"), class = "btn-success")
),
# Show a plot of the generated distribution
mainPanel(
tabsetPanel(
tabPanel("RECOMMENDATIONS", tableOutput("peli")),
tabPanel("RANDOMIZER"),
tabPanel("PELIRANDOM")
),
)
)
)
library(shiny); runApp('MovieApp.R')
>>>>>>> Stashed changes
